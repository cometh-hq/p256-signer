{
  "address": "0x259a123DBb8461f82fa1ed539BA8678e52d3Bda8",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidHash",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSignature",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "x_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "y_",
          "type": "uint256"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initialized",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_hash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        }
      ],
      "name": "isValidSignature",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_hash",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        }
      ],
      "name": "isValidSignature",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "x",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "y",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x5d3cb53a8aba607c594df7ba8de8ed095ae42ead5bcef798f6855b5009d5eea1",
  "receipt": {
    "to": "0x51498fd8a6218bab7eC4286642DE2E194274Cd59",
    "from": "0x65245F19c92ac5Adce53244406Ad126398EF203A",
    "contractAddress": null,
    "transactionIndex": 2,
    "gasUsed": "502877",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa04e91577b96fd84ca9ae2ad9880117aac33d6b64b79b4b170217bc6fc08c652",
    "transactionHash": "0x5d3cb53a8aba607c594df7ba8de8ed095ae42ead5bcef798f6855b5009d5eea1",
    "logs": [],
    "blockNumber": 31519773,
    "cumulativeGasUsed": "1003678",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "9a239a13792e7e509c47a689d8b7e7c4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y_\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_hash\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"x\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"y\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"This contract is the implementation. It is meant to be used through      proxy clone.\",\"kind\":\"dev\",\"methods\":{\"initialize(uint256,uint256)\":{\"details\":\"This function is only callable once and needs to be called immediately      after deployment by the factory in the same transaction.\",\"params\":{\"x_\":\"The x coordinate of the public key\",\"y_\":\"The y coordinate of the public key\"}},\"isValidSignature(bytes,bytes)\":{\"details\":\"This is the old version of the function of EIP-1271 using bytes      memory instead of bytes32\",\"params\":{\"_hash\":\"The hash of the data signed\",\"_signature\":\"The signature\"},\"returns\":{\"_0\":\"The EIP-1271 magic value\"}},\"isValidSignature(bytes32,bytes)\":{\"params\":{\"_hash\":\"The hash of the data signed\",\"_signature\":\"The signature\"},\"returns\":{\"_0\":\"The EIP-1271 magic value\"}}},\"title\":\"P256Signer\",\"version\":1},\"userdoc\":{\"errors\":{\"AlreadyInitialized()\":[{\"notice\":\"Error message when the contract is already initialized\"}],\"InvalidHash()\":[{\"notice\":\"Error message when the hash is invalid\"}],\"InvalidSignature()\":[{\"notice\":\"Error message when the signature is invalid\"}]},\"kind\":\"user\",\"methods\":{\"initialized()\":{\"notice\":\"Whether the contract has been initialized\"},\"isValidSignature(bytes,bytes)\":{\"notice\":\"Verifies that the signer is the owner of the secp256r1 public key.\"},\"isValidSignature(bytes32,bytes)\":{\"notice\":\"Verifies that the signer is the owner of the secp256r1 public key.\"},\"x()\":{\"notice\":\"The x coordinate of the secp256r1 public key\"},\"y()\":{\"notice\":\"The y coordinate of the secp256r1 public key\"}},\"notice\":\"A contract used to verify ECDSA signatures over secp256r1 through         EIP-1271 of Webauthn payloads.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/P256Signer.sol\":\"P256Signer\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"FreshCryptoLib/FCL_Webauthn.sol\":{\"content\":\"//********************************************************************************************/\\n//  ___           _       ___               _         _    _ _\\n// | __| _ ___ __| |_    / __|_ _ _  _ _ __| |_ ___  | |  (_) |__\\n// | _| '_/ -_|_-< ' \\\\  | (__| '_| || | '_ \\\\  _/ _ \\\\ | |__| | '_ \\\\\\n// |_||_| \\\\___/__/_||_|  \\\\___|_|  \\\\_, | .__/\\\\__\\\\___/ |____|_|_.__/\\n///* Copyright (C) 2022 - Renaud Dubois - This file is part of FCL (Fresh CryptoLib) project\\n///* License: This software is licensed under MIT License\\n///* This Code may be reused including license and copyright notice.\\n///* See LICENSE file at the root folder of the project.\\n///* FILE: FCL_elliptic.sol\\n///*\\n///*\\n///* DESCRIPTION: Implementation of the WebAuthn Authentication mechanism\\n///* https://www.w3.org/TR/webauthn-2/#sctn-intro\\n///* Original code extracted from https://github.com/btchip/Webauthn.sol\\n//**************************************************************************************/\\n//* WARNING: this code SHALL not be used for non prime order curves for security reasons.\\n// Code is optimized for a=-3 only curves with prime order, constant like -1, -2 shall be replaced\\n// if ever used for other curve than sec256R1\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {Base64Url} from \\\"./utils/Base64Url.sol\\\";\\nimport {FCL_Elliptic_ZZ} from \\\"./FCL_elliptic.sol\\\";\\n\\nlibrary FCL_WebAuthn {\\n    error InvalidAuthenticatorData();\\n    error InvalidClientData();\\n    error InvalidSignature();\\n\\n    function WebAuthn_format(\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata // rs\\n    ) internal pure returns (bytes32 result) {\\n        // Let the caller check if User Presence (0x01) or User Verification (0x04) are set\\n        {\\n            if ((authenticatorData[32] & authenticatorDataFlagMask) != authenticatorDataFlagMask) {\\n                revert InvalidAuthenticatorData();\\n            }\\n            // Verify that clientData commits to the expected client challenge\\n            // Use the Base64Url encoding which omits padding characters to match WebAuthn Specification\\n            string memory challengeEncoded = Base64Url.encode(abi.encodePacked(clientChallenge));\\n            bytes memory challengeExtracted = new bytes(\\n            bytes(challengeEncoded).length\\n        );\\n\\n            assembly {\\n                calldatacopy(\\n                    add(challengeExtracted, 32),\\n                    add(clientData.offset, clientChallengeDataOffset),\\n                    mload(challengeExtracted)\\n                )\\n            }\\n\\n            bytes32 moreData; //=keccak256(abi.encodePacked(challengeExtracted));\\n            assembly {\\n                moreData := keccak256(add(challengeExtracted, 32), mload(challengeExtracted))\\n            }\\n\\n            if (keccak256(abi.encodePacked(bytes(challengeEncoded))) != moreData) {\\n                revert InvalidClientData();\\n            }\\n        } //avoid stack full\\n\\n        // Verify the signature over sha256(authenticatorData || sha256(clientData))\\n        bytes memory verifyData = new bytes(authenticatorData.length + 32);\\n\\n        assembly {\\n            calldatacopy(add(verifyData, 32), authenticatorData.offset, authenticatorData.length)\\n        }\\n\\n        bytes32 more = sha256(clientData);\\n        assembly {\\n            mstore(add(verifyData, add(authenticatorData.length, 32)), more)\\n        }\\n\\n        return sha256(verifyData);\\n    }\\n\\n    function  checkSignature (\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata rs,\\n        uint256[2] calldata Q\\n    ) internal view returns (bool) {\\n        // Let the caller check if User Presence (0x01) or User Verification (0x04) are set\\n\\n        bytes32 message = FCL_WebAuthn.WebAuthn_format(\\n            authenticatorData, authenticatorDataFlagMask, clientData, clientChallenge, clientChallengeDataOffset, rs\\n        );\\n\\n        bool result = FCL_Elliptic_ZZ.ecdsa_verify(message, rs, Q);\\n\\n        return result;\\n    }\\n\\n    function checkSignature_prec(\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata rs,\\n        address dataPointer\\n    ) internal view returns (bool) {\\n        // Let the caller check if User Presence (0x01) or User Verification (0x04) are set\\n\\n        bytes32 message = FCL_WebAuthn.WebAuthn_format(\\n            authenticatorData, authenticatorDataFlagMask, clientData, clientChallenge, clientChallengeDataOffset, rs\\n        );\\n\\n        bool result = FCL_Elliptic_ZZ.ecdsa_precomputed_verify(message, rs, dataPointer);\\n\\n        return result;\\n    }\\n\\n    //beware that this implementation will not be compliant with EOF\\n    function checkSignature_hackmem(\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata rs,\\n        uint256 dataPointer\\n    ) internal view returns (bool) {\\n        // Let the caller check if User Presence (0x01) or User Verification (0x04) are set\\n\\n        bytes32 message = FCL_WebAuthn.WebAuthn_format(\\n            authenticatorData, authenticatorDataFlagMask, clientData, clientChallenge, clientChallengeDataOffset, rs\\n        );\\n\\n        bool result = FCL_Elliptic_ZZ.ecdsa_precomputed_hackmem(message, rs, dataPointer);\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0x78658514b1f160f17b8408bddc3615b2bfaf83a50c874cdfba26ce90528214b4\",\"license\":\"MIT\"},\"FreshCryptoLib/FCL_elliptic.sol\":{\"content\":\"//********************************************************************************************/\\n//  ___           _       ___               _         _    _ _\\n// | __| _ ___ __| |_    / __|_ _ _  _ _ __| |_ ___  | |  (_) |__\\n// | _| '_/ -_|_-< ' \\\\  | (__| '_| || | '_ \\\\  _/ _ \\\\ | |__| | '_ \\\\\\n// |_||_| \\\\___/__/_||_|  \\\\___|_|  \\\\_, | .__/\\\\__\\\\___/ |____|_|_.__/\\n//                                |__/|_|\\n///* Copyright (C) 2022 - Renaud Dubois - This file is part of FCL (Fresh CryptoLib) project\\n///* License: This software is licensed under MIT License\\n///* This Code may be reused including license and copyright notice.\\n///* See LICENSE file at the root folder of the project.\\n///* FILE: FCL_elliptic.sol\\n///*\\n///*\\n///* DESCRIPTION: modified XYZZ system coordinates for EVM elliptic point multiplication\\n///*  optimization\\n///*\\n//**************************************************************************************/\\n//* WARNING: this code SHALL not be used for non prime order curves for security reasons.\\n// Code is optimized for a=-3 only curves with prime order, constant like -1, -2 shall be replaced\\n// if ever used for other curve than sec256R1\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary FCL_Elliptic_ZZ {\\n    // Set parameters for curve sec256r1.\\n\\n    // address of the ModExp precompiled contract (Arbitrary-precision exponentiation under modulo)\\n    address constant MODEXP_PRECOMPILE = 0x0000000000000000000000000000000000000005;\\n    //curve prime field modulus\\n    uint256 constant p = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n    //short weierstrass first coefficient\\n    uint256 constant a = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\\n    //short weierstrass second coefficient\\n    uint256 constant b = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\\n    //generating point affine coordinates\\n    uint256 constant gx = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\\n    uint256 constant gy = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\\n    //curve order (number of points)\\n    uint256 constant n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\\n    /* -2 mod p constant, used to speed up inversion and doubling (avoid negation)*/\\n    uint256 constant minus_2 = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFD;\\n    /* -2 mod n constant, used to speed up inversion*/\\n    uint256 constant minus_2modn = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC63254F;\\n\\n    uint256 constant minus_1 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    //P+1 div 4\\n    uint256 constant pp1div4=0x3fffffffc0000000400000000000000000000000400000000000000000000000;\\n    //arbitrary constant to express no quadratic residuosity\\n    uint256 constant _NOTSQUARE=0xFFFFFFFF00000002000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 constant _NOTONCURVE=0xFFFFFFFF00000003000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    /**\\n     * /* inversion mod n via a^(n-2), use of precompiled using little Fermat theorem\\n     */\\n    function FCL_nModInv(uint256 u) internal view returns (uint256 result) {\\n        assembly {\\n            let pointer := mload(0x40)\\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n            mstore(pointer, 0x20)\\n            mstore(add(pointer, 0x20), 0x20)\\n            mstore(add(pointer, 0x40), 0x20)\\n            // Define variables base, exponent and modulus\\n            mstore(add(pointer, 0x60), u)\\n            mstore(add(pointer, 0x80), minus_2modn)\\n            mstore(add(pointer, 0xa0), n)\\n\\n            // Call the precompiled contract 0x05 = ModExp\\n            if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\\n            result := mload(pointer)\\n        }\\n    }\\n    /**\\n     * /* @dev inversion mod nusing little Fermat theorem via a^(n-2), use of precompiled\\n     */\\n\\n    function FCL_pModInv(uint256 u) internal view returns (uint256 result) {\\n        assembly {\\n            let pointer := mload(0x40)\\n            // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n            mstore(pointer, 0x20)\\n            mstore(add(pointer, 0x20), 0x20)\\n            mstore(add(pointer, 0x40), 0x20)\\n            // Define variables base, exponent and modulus\\n            mstore(add(pointer, 0x60), u)\\n            mstore(add(pointer, 0x80), minus_2)\\n            mstore(add(pointer, 0xa0), p)\\n\\n            // Call the precompiled contract 0x05 = ModExp\\n            if iszero(staticcall(not(0), 0x05, pointer, 0xc0, pointer, 0x20)) { revert(0, 0) }\\n            result := mload(pointer)\\n        }\\n    }\\n\\n    //Coron projective shuffling, take as input alpha as blinding factor\\n   function ecZZ_Coronize(uint256 alpha, uint256 x, uint256 y,  uint256 zz, uint256 zzz) public pure  returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\\n   {\\n       \\n        uint256 alpha2=mulmod(alpha,alpha,p);\\n       \\n        x3=mulmod(alpha2, x,p); //alpha^-2.x\\n        y3=mulmod(mulmod(alpha, alpha2,p), y,p);\\n\\n        zz3=mulmod(zz,alpha2,p);//alpha^2 zz\\n        zzz3=mulmod(zzz,mulmod(alpha, alpha2,p),p);//alpha^3 zzz\\n        \\n        return (x3, y3, zz3, zzz3);\\n   }\\n\\n\\n function ecZZ_Add(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2, uint256 zz2, uint256 zzz2) internal pure  returns (uint256 x3, uint256 y3, uint256 zz3, uint256 zzz3)\\n  {\\n    uint256 u1=mulmod(x1,zz2,p); // U1 = X1*ZZ2\\n    uint256 u2=mulmod(x2, zz1,p);               //  U2 = X2*ZZ1\\n    u2=addmod(u2, p-u1, p);//  P = U2-U1\\n    x1=mulmod(u2, u2, p);//PP\\n    x2=mulmod(x1, u2, p);//PPP\\n    \\n    zz3=mulmod(x1, mulmod(zz1, zz2, p),p);//ZZ3 = ZZ1*ZZ2*PP  \\n    zzz3=mulmod(zzz1, mulmod(zzz2, x2, p),p);//ZZZ3 = ZZZ1*ZZZ2*PPP\\n\\n    zz1=mulmod(y1, zzz2,p);  // S1 = Y1*ZZZ2\\n    zz2=mulmod(y2, zzz1, p);    // S2 = Y2*ZZZ1 \\n    zz2=addmod(zz2, p-zz1, p);//R = S2-S1\\n    zzz1=mulmod(u1, x1,p); //Q = U1*PP\\n    x3= addmod(addmod(mulmod(zz2, zz2, p), p-x2,p), mulmod(minus_2, zzz1,p),p); //X3 = R2-PPP-2*Q\\n    y3=addmod( mulmod(zz2, addmod(zzz1, p-x3, p),p), p-mulmod(zz1, x2, p),p);//R*(Q-X3)-S1*PPP\\n\\n    return (x3, y3, zz3, zzz3);\\n  }\\n\\n/// @notice Calculate one modular square root of a given integer. Assume that p=3 mod 4.\\n/// @dev Uses the ModExp precompiled contract at address 0x05 for fast computation using little Fermat theorem\\n/// @param self The integer of which to find the modular inverse\\n/// @return result The modular inverse of the input integer. If the modular inverse doesn't exist, it revert the tx\\n\\nfunction SqrtMod(uint256 self) internal view returns (uint256 result){\\n assembly (\\\"memory-safe\\\") {\\n        // load the free memory pointer value\\n        let pointer := mload(0x40)\\n\\n        // Define length of base (Bsize)\\n        mstore(pointer, 0x20)\\n        // Define the exponent size (Esize)\\n        mstore(add(pointer, 0x20), 0x20)\\n        // Define the modulus size (Msize)\\n        mstore(add(pointer, 0x40), 0x20)\\n        // Define variables base (B)\\n        mstore(add(pointer, 0x60), self)\\n        // Define the exponent (E)\\n        mstore(add(pointer, 0x80), pp1div4)\\n        // We save the point of the last argument, it will be override by the result\\n        // of the precompile call in order to avoid paying for the memory expansion properly\\n        let _result := add(pointer, 0xa0)\\n        // Define the modulus (M)\\n        mstore(_result, p)\\n\\n        // Call the precompiled ModExp (0x05) https://www.evm.codes/precompiled#0x05\\n        if iszero(\\n            staticcall(\\n                not(0), // amount of gas to send\\n                MODEXP_PRECOMPILE, // target\\n                pointer, // argsOffset\\n                0xc0, // argsSize (6 * 32 bytes)\\n                _result, // retOffset (we override M to avoid paying for the memory expansion)\\n                0x20 // retSize (32 bytes)\\n            )\\n        ) { revert(0, 0) }\\n\\n  result := mload(_result)\\n//  result :=addmod(result,0,p)\\n }\\n   if(mulmod(result,result,p)!=self){\\n     result=_NOTSQUARE;\\n   }\\n  \\n   return result;\\n}\\n    /**\\n     * /* @dev Convert from affine rep to XYZZ rep\\n     */\\n    function ecAff_SetZZ(uint256 x0, uint256 y0) internal pure returns (uint256[4] memory P) {\\n        unchecked {\\n            P[2] = 1; //ZZ\\n            P[3] = 1; //ZZZ\\n            P[0] = x0;\\n            P[1] = y0;\\n        }\\n    }\\n\\n    function ec_Decompress(uint256 x, uint256 parity) internal view returns(uint256 y){ \\n\\n        uint256 y2=mulmod(x,mulmod(x,x,p),p);//x3\\n        y2=addmod(b,addmod(y2,mulmod(x,a,p),p),p);//x3+ax+b\\n\\n        y=SqrtMod(y2);\\n        if(y==_NOTSQUARE){\\n           return _NOTONCURVE;\\n        }\\n        if((y&1)!=(parity&1)){\\n            y=p-y;\\n        }\\n    }\\n\\n    /**\\n     * /* @dev Convert from XYZZ rep to affine rep\\n     */\\n    /*    https://hyperelliptic.org/EFD/g1p/auto-shortw-xyzz-3.html#addition-add-2008-s*/\\n    function ecZZ_SetAff(uint256 x, uint256 y, uint256 zz, uint256 zzz) internal view returns (uint256 x1, uint256 y1) {\\n        uint256 zzzInv = FCL_pModInv(zzz); //1/zzz\\n        y1 = mulmod(y, zzzInv, p); //Y/zzz\\n        uint256 _b = mulmod(zz, zzzInv, p); //1/z\\n        zzzInv = mulmod(_b, _b, p); //1/zz\\n        x1 = mulmod(x, zzzInv, p); //X/zz\\n    }\\n\\n    /**\\n     * /* @dev Sutherland2008 doubling\\n     */\\n    /* The \\\"dbl-2008-s-1\\\" doubling formulas */\\n\\n    function ecZZ_Dbl(uint256 x, uint256 y, uint256 zz, uint256 zzz)\\n        internal\\n        pure\\n        returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\\n    {\\n        unchecked {\\n            assembly {\\n                P0 := mulmod(2, y, p) //U = 2*Y1\\n                P2 := mulmod(P0, P0, p) // V=U^2\\n                P3 := mulmod(x, P2, p) // S = X1*V\\n                P1 := mulmod(P0, P2, p) // W=UV\\n                P2 := mulmod(P2, zz, p) //zz3=V*ZZ1\\n                zz := mulmod(3, mulmod(addmod(x, sub(p, zz), p), addmod(x, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                P0 := addmod(mulmod(zz, zz, p), mulmod(minus_2, P3, p), p) //X3=M^2-2S\\n                x := mulmod(zz, addmod(P3, sub(p, P0), p), p) //M(S-X3)\\n                P3 := mulmod(P1, zzz, p) //zzz3=W*zzz1\\n                P1 := addmod(x, sub(p, mulmod(P1, y, p)), p) //Y3= M(S-X3)-W*Y1\\n            }\\n        }\\n        return (P0, P1, P2, P3);\\n    }\\n\\n    /**\\n     * @dev Sutherland2008 add a ZZ point with a normalized point and greedy formulae\\n     * warning: assume that P1(x1,y1)!=P2(x2,y2), true in multiplication loop with prime order (cofactor 1)\\n     */\\n\\n    function ecZZ_AddN(uint256 x1, uint256 y1, uint256 zz1, uint256 zzz1, uint256 x2, uint256 y2)\\n        internal\\n        pure\\n        returns (uint256 P0, uint256 P1, uint256 P2, uint256 P3)\\n    {\\n        unchecked {\\n            if (y1 == 0) {\\n                return (x2, y2, 1, 1);\\n            }\\n\\n            assembly {\\n                y1 := sub(p, y1)\\n                y2 := addmod(mulmod(y2, zzz1, p), y1, p)\\n                x2 := addmod(mulmod(x2, zz1, p), sub(p, x1), p)\\n                P0 := mulmod(x2, x2, p) //PP = P^2\\n                P1 := mulmod(P0, x2, p) //PPP = P*PP\\n                P2 := mulmod(zz1, P0, p) ////ZZ3 = ZZ1*PP\\n                P3 := mulmod(zzz1, P1, p) ////ZZZ3 = ZZZ1*PPP\\n                zz1 := mulmod(x1, P0, p) //Q = X1*PP\\n                P0 := addmod(addmod(mulmod(y2, y2, p), sub(p, P1), p), mulmod(minus_2, zz1, p), p) //R^2-PPP-2*Q\\n                P1 := addmod(mulmod(addmod(zz1, sub(p, P0), p), y2, p), mulmod(y1, P1, p), p) //R*(Q-X3)\\n            }\\n            //end assembly\\n        } //end unchecked\\n        return (P0, P1, P2, P3);\\n    }\\n\\n    /**\\n     * @dev Return the zero curve in XYZZ coordinates.\\n     */\\n    function ecZZ_SetZero() internal pure returns (uint256 x, uint256 y, uint256 zz, uint256 zzz) {\\n        return (0, 0, 0, 0);\\n    }\\n    /**\\n     * @dev Check if point is the neutral of the curve\\n     */\\n\\n    // uint256 x0, uint256 y0, uint256 zz0, uint256 zzz0\\n    function ecZZ_IsZero(uint256, uint256 y0, uint256, uint256) internal pure returns (bool) {\\n        return y0 == 0;\\n    }\\n    /**\\n     * @dev Return the zero curve in affine coordinates. Compatible with the double formulae (no special case)\\n     */\\n\\n    function ecAff_SetZero() internal pure returns (uint256 x, uint256 y) {\\n        return (0, 0);\\n    }\\n\\n    /**\\n     * @dev Check if the curve is the zero curve in affine rep.\\n     */\\n    // uint256 x, uint256 y)\\n    function ecAff_IsZero(uint256, uint256 y) internal pure returns (bool flag) {\\n        return (y == 0);\\n    }\\n\\n    /**\\n     * @dev Check if a point in affine coordinates is on the curve (reject Neutral that is indeed on the curve).\\n     */\\n    function ecAff_isOnCurve(uint256 x, uint256 y) internal pure returns (bool) {\\n        if (0 == x || x == p || 0 == y || y == p) {\\n            return false;\\n        }\\n        unchecked {\\n            uint256 LHS = mulmod(y, y, p); // y^2\\n            uint256 RHS = addmod(mulmod(mulmod(x, x, p), x, p), mulmod(x, a, p), p); // x^3+ax\\n            RHS = addmod(RHS, b, p); // x^3 + a*x + b\\n\\n            return LHS == RHS;\\n        }\\n    }\\n\\n    /**\\n     * @dev Add two elliptic curve points in affine coordinates.\\n     */\\n\\n    function ecAff_add(uint256 x0, uint256 y0, uint256 x1, uint256 y1) internal view returns (uint256, uint256) {\\n        uint256 zz0;\\n        uint256 zzz0;\\n\\n        if (ecAff_IsZero(x0, y0)) return (x1, y1);\\n        if (ecAff_IsZero(x1, y1)) return (x0, y0);\\n\\n        (x0, y0, zz0, zzz0) = ecZZ_AddN(x0, y0, 1, 1, x1, y1);\\n\\n        return ecZZ_SetAff(x0, y0, zz0, zzz0);\\n    }\\n\\n    /**\\n     * @dev Computation of uG+vQ using Strauss-Shamir's trick, G basepoint, Q public key\\n     *       Returns only x for ECDSA use            \\n     *      */\\n    function ecZZ_mulmuladd_S_asm(\\n        uint256 Q0,\\n        uint256 Q1, //affine rep for input point Q\\n        uint256 scalar_u,\\n        uint256 scalar_v\\n    ) internal view returns (uint256 X) {\\n        uint256 zz;\\n        uint256 zzz;\\n        uint256 Y;\\n        uint256 index = 255;\\n        uint256 H0;\\n        uint256 H1;\\n\\n        unchecked {\\n            if (scalar_u == 0 && scalar_v == 0) return 0;\\n\\n            (H0, H1) = ecAff_add(gx, gy, Q0, Q1); //will not work if Q=P, obvious forbidden private key\\n\\n            assembly {\\n                for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\\n                    index := sub(index, 1)\\n                    T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n                } {}\\n                zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n\\n                if eq(zz, 1) {\\n                    X := gx\\n                    Y := gy\\n                }\\n                if eq(zz, 2) {\\n                    X := Q0\\n                    Y := Q1\\n                }\\n                if eq(zz, 3) {\\n                    X := H0\\n                    Y := H1\\n                }\\n\\n                index := sub(index, 1)\\n                zz := 1\\n                zzz := 1\\n\\n                for {} gt(minus_1, index) { index := sub(index, 1) } {\\n                    // inlined EcZZ_Dbl\\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\\n                    let T2 := mulmod(T1, T1, p) // V=U^2\\n                    let T3 := mulmod(X, T2, p) // S = X1*V\\n                    T1 := mulmod(T1, T2, p) // W=UV\\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\\n\\n                    {\\n                        //value of dibit\\n                        T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n\\n                        if iszero(T4) {\\n                            Y := sub(p, Y) //restore the -Y inversion\\n                            continue\\n                        } // if T4!=0\\n\\n                        if eq(T4, 1) {\\n                            T1 := gx\\n                            T2 := gy\\n                        }\\n                        if eq(T4, 2) {\\n                            T1 := Q0\\n                            T2 := Q1\\n                        }\\n                        if eq(T4, 3) {\\n                            T1 := H0\\n                            T2 := H1\\n                        }\\n                        if iszero(zz) {\\n                            X := T1\\n                            Y := T2\\n                            zz := 1\\n                            zzz := 1\\n                            continue\\n                        }\\n                        // inlined EcZZ_AddN\\n\\n                        //T3:=sub(p, Y)\\n                        //T3:=Y\\n                        let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\\n                        T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\\n\\n                        //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\\n                        //todo : construct edge vector case\\n                        if iszero(y2) {\\n                            if iszero(T2) {\\n                                T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\\n                                T2 := mulmod(T1, T1, p) // V=U^2\\n                                T3 := mulmod(X, T2, p) // S = X1*V\\n\\n                                T1 := mulmod(T1, T2, p) // W=UV\\n                                y2 := addmod(X, zz, p)  //X+ZZ\\n                                let TT1 := addmod(X, sub(p, zz), p) //X-ZZ\\n                                y2 := mulmod(y2, TT1, p) //(X-ZZ)(X+ZZ)\\n                                T4 := mulmod(3, y2, p) //M\\n\\n                                zzz := mulmod(TT1, zzz, p) //zzz3=W*zzz1\\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\\n\\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\\n\\n                                continue\\n                            }\\n                        }\\n\\n                        T4 := mulmod(T2, T2, p) //PP\\n                        let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\\n                        zz := mulmod(zz, T4, p)\\n                        zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\\n                        let TT2 := mulmod(X, T4, p)\\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\\n                        Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\\n\\n                        X := T4\\n                    }\\n                } //end loop\\n                let T := mload(0x40)\\n                mstore(add(T, 0x60), zz)\\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n                mstore(T, 0x20)\\n                mstore(add(T, 0x20), 0x20)\\n                mstore(add(T, 0x40), 0x20)\\n                // Define variables base, exponent and modulus\\n                //mstore(add(pointer, 0x60), u)\\n                mstore(add(T, 0x80), minus_2)\\n                mstore(add(T, 0xa0), p)\\n\\n                // Call the precompiled contract 0x05 = ModExp\\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\\n\\n                //Y:=mulmod(Y,zzz,p)//Y/zzz\\n                //zz :=mulmod(zz, mload(T),p) //1/z\\n                //zz:= mulmod(zz,zz,p) //1/zz\\n                X := mulmod(X, mload(T), p) //X/zz\\n            } //end assembly\\n        } //end unchecked\\n\\n        return X;\\n    }\\n\\n\\n    /**\\n     * @dev Computation of uG+vQ using Strauss-Shamir's trick, G basepoint, Q public key\\n     *       Returns affine representation of point (normalized)       \\n     *      */\\n    function ecZZ_mulmuladd(\\n        uint256 Q0,\\n        uint256 Q1, //affine rep for input point Q\\n        uint256 scalar_u,\\n        uint256 scalar_v\\n    ) internal view returns (uint256 X, uint256 Y) {\\n        uint256 zz;\\n        uint256 zzz;\\n        uint256 index = 255;\\n        uint256[6] memory T;\\n        uint256[2] memory H;\\n \\n        unchecked {\\n            if (scalar_u == 0 && scalar_v == 0) return (0,0);\\n\\n            (H[0], H[1]) = ecAff_add(gx, gy, Q0, Q1); //will not work if Q=P, obvious forbidden private key\\n\\n            assembly {\\n                for { let T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1)) } eq(T4, 0) {\\n                    index := sub(index, 1)\\n                    T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n                } {}\\n                zz := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n\\n                if eq(zz, 1) {\\n                    X := gx\\n                    Y := gy\\n                }\\n                if eq(zz, 2) {\\n                    X := Q0\\n                    Y := Q1\\n                }\\n                if eq(zz, 3) {\\n                    Y := mload(add(H,32))\\n                    X := mload(H)\\n                }\\n\\n                index := sub(index, 1)\\n                zz := 1\\n                zzz := 1\\n\\n                for {} gt(minus_1, index) { index := sub(index, 1) } {\\n                    // inlined EcZZ_Dbl\\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\\n                    let T2 := mulmod(T1, T1, p) // V=U^2\\n                    let T3 := mulmod(X, T2, p) // S = X1*V\\n                    T1 := mulmod(T1, T2, p) // W=UV\\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\\n\\n                    {\\n                        //value of dibit\\n                        T4 := add(shl(1, and(shr(index, scalar_v), 1)), and(shr(index, scalar_u), 1))\\n\\n                        if iszero(T4) {\\n                            Y := sub(p, Y) //restore the -Y inversion\\n                            continue\\n                        } // if T4!=0\\n\\n                        if eq(T4, 1) {\\n                            T1 := gx\\n                            T2 := gy\\n                        }\\n                        if eq(T4, 2) {\\n                            T1 := Q0\\n                            T2 := Q1\\n                        }\\n                        if eq(T4, 3) {\\n                            T1 := mload(H)\\n                            T2 := mload(add(H,32))\\n                        }\\n                        if iszero(zz) {\\n                            X := T1\\n                            Y := T2\\n                            zz := 1\\n                            zzz := 1\\n                            continue\\n                        }\\n                        // inlined EcZZ_AddN\\n\\n                        //T3:=sub(p, Y)\\n                        //T3:=Y\\n                        let y2 := addmod(mulmod(T2, zzz, p), Y, p) //R\\n                        T2 := addmod(mulmod(T1, zz, p), sub(p, X), p) //P\\n\\n                        //special extremely rare case accumulator where EcAdd is replaced by EcDbl, no need to optimize this\\n                        //todo : construct edge vector case\\n                        if iszero(y2) {\\n                            if iszero(T2) {\\n                                T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\\n                                T2 := mulmod(T1, T1, p) // V=U^2\\n                                T3 := mulmod(X, T2, p) // S = X1*V\\n\\n                                T1 := mulmod(T1, T2, p) // W=UV\\n                                y2 := addmod(X, zz, p) //X+ZZ\\n                                let TT1 := addmod(X, sub(p, zz), p) //X-ZZ\\n                                y2 := mulmod(y2, TT1, p) //(X-ZZ)(X+ZZ)\\n                                T4 := mulmod(3, y2, p) //M\\n\\n                                zzz := mulmod(TT1, zzz, p) //zzz3=W*zzz1\\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\\n\\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\\n\\n                                continue\\n                            }\\n                        }\\n\\n                        T4 := mulmod(T2, T2, p) //PP\\n                        let TT1 := mulmod(T4, T2, p) //PPP, this one could be spared, but adding this register spare gas\\n                        zz := mulmod(zz, T4, p)\\n                        zzz := mulmod(zzz, TT1, p) //zz3=V*ZZ1\\n                        let TT2 := mulmod(X, T4, p)\\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, TT1), p), mulmod(minus_2, TT2, p), p)\\n                        Y := addmod(mulmod(addmod(TT2, sub(p, T4), p), y2, p), mulmod(Y, TT1, p), p)\\n\\n                        X := T4\\n                    }\\n                } //end loop\\n                mstore(add(T, 0x60), zzz)\\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n                mstore(T, 0x20)\\n                mstore(add(T, 0x20), 0x20)\\n                mstore(add(T, 0x40), 0x20)\\n                // Define variables base, exponent and modulus\\n                //mstore(add(pointer, 0x60), u)\\n                mstore(add(T, 0x80), minus_2)\\n                mstore(add(T, 0xa0), p)\\n\\n                // Call the precompiled contract 0x05 = ModExp\\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\\n\\n                Y:=mulmod(Y,mload(T),p)//Y/zzz\\n                zz :=mulmod(zz, mload(T),p) //1/z\\n                zz:= mulmod(zz,zz,p) //1/zz\\n                X := mulmod(X, zz, p) //X/zz\\n            } //end assembly\\n        } //end unchecked\\n\\n        return (X,Y);\\n    }\\n\\n    //8 dimensions Shamir's trick, using precomputations stored in Shamir8,  stored as Bytecode of an external\\n    //contract at given address dataPointer\\n    //(thx to Lakhdar https://github.com/Kelvyne for EVM storage explanations and tricks)\\n    // the external tool to generate tables from public key is in the /sage directory\\n    function ecZZ_mulmuladd_S8_extcode(uint256 scalar_u, uint256 scalar_v, address dataPointer)\\n        internal view\\n        returns (uint256 X /*, uint Y*/ )\\n    {\\n        unchecked {\\n            uint256 zz; // third and  coordinates of the point\\n\\n            uint256[6] memory T;\\n            zz = 256; //start index\\n\\n            while (T[0] == 0) {\\n                zz = zz - 1;\\n                //tbd case of msb octobit is null\\n                T[0] = 64\\n                    * (\\n                        128 * ((scalar_v >> zz) & 1) + 64 * ((scalar_v >> (zz - 64)) & 1)\\n                            + 32 * ((scalar_v >> (zz - 128)) & 1) + 16 * ((scalar_v >> (zz - 192)) & 1)\\n                            + 8 * ((scalar_u >> zz) & 1) + 4 * ((scalar_u >> (zz - 64)) & 1)\\n                            + 2 * ((scalar_u >> (zz - 128)) & 1) + ((scalar_u >> (zz - 192)) & 1)\\n                    );\\n            }\\n            assembly {\\n                extcodecopy(dataPointer, T, mload(T), 64)\\n                let index := sub(zz, 1)\\n                X := mload(T)\\n                let Y := mload(add(T, 32))\\n                let zzz := 1\\n                zz := 1\\n\\n                //loop over 1/4 of scalars thx to Shamir's trick over 8 points\\n                for {} gt(index, 191) { index := add(index, 191) } {\\n                    //inline Double\\n                    {\\n                        let TT1 := mulmod(2, Y, p) //U = 2*Y1, y free\\n                        let T2 := mulmod(TT1, TT1, p) // V=U^2\\n                        let T3 := mulmod(X, T2, p) // S = X1*V\\n                        let T1 := mulmod(TT1, T2, p) // W=UV\\n                        let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                        zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\\n                        zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                        X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                        //T2:=mulmod(T4,addmod(T3, sub(p, X),p),p)//M(S-X3)\\n                        let T5 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\\n\\n                        //Y:= addmod(T2, sub(p, mulmod(T1, Y ,p)),p  )//Y3= M(S-X3)-W*Y1\\n                        Y := addmod(mulmod(T1, Y, p), T5, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\\n\\n                        /* compute element to access in precomputed table */\\n                    }\\n                    {\\n                        let T4 := add(shl(13, and(shr(index, scalar_v), 1)), shl(9, and(shr(index, scalar_u), 1)))\\n                        let index2 := sub(index, 64)\\n                        let T3 :=\\n                            add(T4, add(shl(12, and(shr(index2, scalar_v), 1)), shl(8, and(shr(index2, scalar_u), 1))))\\n                        let index3 := sub(index2, 64)\\n                        let T2 :=\\n                            add(T3, add(shl(11, and(shr(index3, scalar_v), 1)), shl(7, and(shr(index3, scalar_u), 1))))\\n                        index := sub(index3, 64)\\n                        let T1 :=\\n                            add(T2, add(shl(10, and(shr(index, scalar_v), 1)), shl(6, and(shr(index, scalar_u), 1))))\\n\\n                        //tbd: check validity of formulae with (0,1) to remove conditional jump\\n                        if iszero(T1) {\\n                            Y := sub(p, Y)\\n\\n                            continue\\n                        }\\n                        extcodecopy(dataPointer, T, T1, 64)\\n                    }\\n\\n                    {\\n                        /* Access to precomputed table using extcodecopy hack */\\n\\n                        // inlined EcZZ_AddN\\n                        if iszero(zz) {\\n                            X := mload(T)\\n                            Y := mload(add(T, 32))\\n                            zz := 1\\n                            zzz := 1\\n\\n                            continue\\n                        }\\n\\n                        let y2 := addmod(mulmod(mload(add(T, 32)), zzz, p), Y, p)\\n                        let T2 := addmod(mulmod(mload(T), zz, p), sub(p, X), p)\\n\\n                        //special case ecAdd(P,P)=EcDbl\\n                        if iszero(y2) {\\n                            if iszero(T2) {\\n                                let T1 := mulmod(minus_2, Y, p) //U = 2*Y1, y free\\n                                T2 := mulmod(T1, T1, p) // V=U^2\\n                                let T3 := mulmod(X, T2, p) // S = X1*V\\n\\n                                T1 := mulmod(T1, T2, p) // W=UV\\n                                y2 := addmod(X, zz, p) //X+ZZ\\n                                let TT1 := addmod(X, sub(p, zz), p) //X-ZZ\\n                                y2 := mulmod(y2, TT1, p) //(X-ZZ)(X+ZZ)\\n                                let T4 := mulmod(3, y2, p) //M\\n\\n                                zzz := mulmod(TT1, zzz, p) //zzz3=W*zzz1\\n                                zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                                X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                                T2 := mulmod(T4, addmod(T3, sub(p, X), p), p) //M(S-X3)\\n\\n                                Y := addmod(T2, mulmod(T1, Y, p), p) //Y3= M(S-X3)-W*Y1\\n\\n                                continue\\n                            }\\n                        }\\n\\n                        let T4 := mulmod(T2, T2, p)\\n                        let T1 := mulmod(T4, T2, p) //\\n                        zz := mulmod(zz, T4, p)\\n                        //zzz3=V*ZZ1\\n                        zzz := mulmod(zzz, T1, p) // W=UV/\\n                        let zz1 := mulmod(X, T4, p)\\n                        X := addmod(addmod(mulmod(y2, y2, p), sub(p, T1), p), mulmod(minus_2, zz1, p), p)\\n                        Y := addmod(mulmod(addmod(zz1, sub(p, X), p), y2, p), mulmod(Y, T1, p), p)\\n                    }\\n                } //end loop\\n                mstore(add(T, 0x60), zz)\\n\\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n                mstore(T, 0x20)\\n                mstore(add(T, 0x20), 0x20)\\n                mstore(add(T, 0x40), 0x20)\\n                // Define variables base, exponent and modulus\\n                //mstore(add(pointer, 0x60), u)\\n                mstore(add(T, 0x80), minus_2)\\n                mstore(add(T, 0xa0), p)\\n\\n                // Call the precompiled contract 0x05 = ModExp\\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\\n\\n                zz := mload(T)\\n                X := mulmod(X, zz, p) //X/zz\\n            }\\n        } //end unchecked\\n    }\\n\\n   \\n\\n    // improving the extcodecopy trick : append array at end of contract\\n    function ecZZ_mulmuladd_S8_hackmem(uint256 scalar_u, uint256 scalar_v, uint256 dataPointer)\\n        internal view\\n        returns (uint256 X /*, uint Y*/ )\\n    {\\n        uint256 zz; // third and  coordinates of the point\\n\\n        uint256[6] memory T;\\n        zz = 256; //start index\\n\\n        unchecked {\\n            while (T[0] == 0) {\\n                zz = zz - 1;\\n                //tbd case of msb octobit is null\\n                T[0] = 64\\n                    * (\\n                        128 * ((scalar_v >> zz) & 1) + 64 * ((scalar_v >> (zz - 64)) & 1)\\n                            + 32 * ((scalar_v >> (zz - 128)) & 1) + 16 * ((scalar_v >> (zz - 192)) & 1)\\n                            + 8 * ((scalar_u >> zz) & 1) + 4 * ((scalar_u >> (zz - 64)) & 1)\\n                            + 2 * ((scalar_u >> (zz - 128)) & 1) + ((scalar_u >> (zz - 192)) & 1)\\n                    );\\n            }\\n            assembly {\\n                codecopy(T, add(mload(T), dataPointer), 64)\\n                X := mload(T)\\n                let Y := mload(add(T, 32))\\n                let zzz := 1\\n                zz := 1\\n\\n                //loop over 1/4 of scalars thx to Shamir's trick over 8 points\\n                for { let index := 254 } gt(index, 191) { index := add(index, 191) } {\\n                    let T1 := mulmod(2, Y, p) //U = 2*Y1, y free\\n                    let T2 := mulmod(T1, T1, p) // V=U^2\\n                    let T3 := mulmod(X, T2, p) // S = X1*V\\n                    T1 := mulmod(T1, T2, p) // W=UV\\n                    let T4 := mulmod(3, mulmod(addmod(X, sub(p, zz), p), addmod(X, zz, p), p), p) //M=3*(X1-ZZ1)*(X1+ZZ1)\\n                    zzz := mulmod(T1, zzz, p) //zzz3=W*zzz1\\n                    zz := mulmod(T2, zz, p) //zz3=V*ZZ1, V free\\n\\n                    X := addmod(mulmod(T4, T4, p), mulmod(minus_2, T3, p), p) //X3=M^2-2S\\n                    //T2:=mulmod(T4,addmod(T3, sub(p, X),p),p)//M(S-X3)\\n                    T2 := mulmod(T4, addmod(X, sub(p, T3), p), p) //-M(S-X3)=M(X3-S)\\n\\n                    //Y:= addmod(T2, sub(p, mulmod(T1, Y ,p)),p  )//Y3= M(S-X3)-W*Y1\\n                    Y := addmod(mulmod(T1, Y, p), T2, p) //-Y3= W*Y1-M(S-X3), we replace Y by -Y to avoid a sub in ecAdd\\n\\n                    /* compute element to access in precomputed table */\\n                    T4 := add(shl(13, and(shr(index, scalar_v), 1)), shl(9, and(shr(index, scalar_u), 1)))\\n                    index := sub(index, 64)\\n                    T4 := add(T4, add(shl(12, and(shr(index, scalar_v), 1)), shl(8, and(shr(index, scalar_u), 1))))\\n                    index := sub(index, 64)\\n                    T4 := add(T4, add(shl(11, and(shr(index, scalar_v), 1)), shl(7, and(shr(index, scalar_u), 1))))\\n                    index := sub(index, 64)\\n                    T4 := add(T4, add(shl(10, and(shr(index, scalar_v), 1)), shl(6, and(shr(index, scalar_u), 1))))\\n                    //index:=add(index,192), restore index, interleaved with loop\\n\\n                    //tbd: check validity of formulae with (0,1) to remove conditional jump\\n                    if iszero(T4) {\\n                        Y := sub(p, Y)\\n\\n                        continue\\n                    }\\n                    {\\n                        /* Access to precomputed table using extcodecopy hack */\\n                        codecopy(T, add(T4, dataPointer), 64)\\n\\n                        // inlined EcZZ_AddN\\n\\n                        let y2 := addmod(mulmod(mload(add(T, 32)), zzz, p), Y, p)\\n                        T2 := addmod(mulmod(mload(T), zz, p), sub(p, X), p)\\n                        T4 := mulmod(T2, T2, p)\\n                        T1 := mulmod(T4, T2, p)\\n                        T2 := mulmod(zz, T4, p) // W=UV\\n                        zzz := mulmod(zzz, T1, p) //zz3=V*ZZ1\\n                        let zz1 := mulmod(X, T4, p)\\n                        T4 := addmod(addmod(mulmod(y2, y2, p), sub(p, T1), p), mulmod(minus_2, zz1, p), p)\\n                        Y := addmod(mulmod(addmod(zz1, sub(p, T4), p), y2, p), mulmod(Y, T1, p), p)\\n                        zz := T2\\n                        X := T4\\n                    }\\n                } //end loop\\n                mstore(add(T, 0x60), zz)\\n\\n                //(X,Y)=ecZZ_SetAff(X,Y,zz, zzz);\\n                //T[0] = inverseModp_Hard(T[0], p); //1/zzz, inline modular inversion using precompile:\\n                // Define length of base, exponent and modulus. 0x20 == 32 bytes\\n                mstore(T, 0x20)\\n                mstore(add(T, 0x20), 0x20)\\n                mstore(add(T, 0x40), 0x20)\\n                // Define variables base, exponent and modulus\\n                //mstore(add(pointer, 0x60), u)\\n                mstore(add(T, 0x80), minus_2)\\n                mstore(add(T, 0xa0), p)\\n\\n                // Call the precompiled contract 0x05 = ModExp\\n                if iszero(staticcall(not(0), 0x05, T, 0xc0, T, 0x20)) { revert(0, 0) }\\n\\n                zz := mload(T)\\n                X := mulmod(X, zz, p) //X/zz\\n            }\\n        } //end unchecked\\n    }\\n\\n    /**\\n     * @dev ECDSA verification, given , signature, and public key.\\n     */\\n    function ecdsa_verify(bytes32 message, uint256[2] calldata rs, uint256[2] calldata Q) internal view returns (bool) {\\n        uint256 r = rs[0];\\n        uint256 s = rs[1];\\n        if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return false;\\n        }\\n        uint256 Q0 = Q[0];\\n        uint256 Q1 = Q[1];\\n        if (!ecAff_isOnCurve(Q0, Q1)) {\\n            return false;\\n        }\\n\\n        uint256 sInv = FCL_nModInv(s);\\n\\n        uint256 scalar_u = mulmod(uint256(message), sInv, n);\\n        uint256 scalar_v = mulmod(r, sInv, n);\\n        uint256 x1;\\n\\n        x1 = ecZZ_mulmuladd_S_asm(Q0, Q1, scalar_u, scalar_v);\\n\\n        assembly {\\n            x1 := addmod(x1, sub(n, r), n)\\n        }\\n        //return true;\\n        return x1 == 0;\\n    }\\n\\n    /**\\n     * @dev ECDSA verification using a precomputed table of multiples of P and Q stored in contract at address Shamir8\\n     *     generation of contract bytecode for precomputations is done using sagemath code\\n     *     (see sage directory, WebAuthn_precompute.sage)\\n     */\\n\\n    function ecdsa_precomputed_verify(bytes32 message, uint256[2] calldata rs, address Shamir8)\\n        internal view\\n        returns (bool)\\n    {\\n        uint256 r = rs[0];\\n        uint256 s = rs[1];\\n        if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return false;\\n        }\\n        /* Q is pushed via bytecode assumed to be correct\\n        if (!isOnCurve(Q[0], Q[1])) {\\n            return false;\\n        }*/\\n\\n        uint256 sInv = FCL_nModInv(s);\\n\\n        uint256 X;\\n\\n        //Shamir 8 dimensions\\n        X = ecZZ_mulmuladd_S8_extcode(mulmod(uint256(message), sInv, n), mulmod(r, sInv, n), Shamir8);\\n\\n        assembly {\\n            X := addmod(X, sub(n, r), n)\\n        }\\n\\n        return X == 0;\\n    } //end  ecdsa_precomputed_verify()\\n\\n    /**\\n     * @dev ECDSA verification using a precomputed table of multiples of P and Q appended at end of contract at address endcontract\\n     *     generation of contract bytecode for precomputations is done using sagemath code\\n     *     (see sage directory, WebAuthn_precompute.sage)\\n     */\\n\\n    function ecdsa_precomputed_hackmem(bytes32 message, uint256[2] calldata rs, uint256 endcontract)\\n        internal view\\n        returns (bool)\\n    {\\n        uint256 r = rs[0];\\n        uint256 s = rs[1];\\n        if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return false;\\n        }\\n        /* Q is pushed via bytecode assumed to be correct\\n        if (!isOnCurve(Q[0], Q[1])) {\\n            return false;\\n        }*/\\n\\n        uint256 sInv = FCL_nModInv(s);\\n        uint256 X;\\n\\n        //Shamir 8 dimensions\\n        X = ecZZ_mulmuladd_S8_hackmem(mulmod(uint256(message), sInv, n), mulmod(r, sInv, n), endcontract);\\n\\n        assembly {\\n            X := addmod(X, sub(n, r), n)\\n        }\\n        return X == 0;\\n    } //end  ecdsa_precomputed_verify()\\n\\n    function ec_recover_r1(uint256 h, uint256 v, uint256 r, uint256 s) public view returns (address)\\n    {\\n         if (r == 0 || r >= n || s == 0 || s >= n) {\\n            return address(0);\\n        }\\n        uint256 y=ec_Decompress(r, v-27);\\n        uint256 rinv=FCL_nModInv(r);\\n        uint256 u1=mulmod(n-addmod(0,h,n), rinv,n);//-hr^-1\\n        uint256 u2=mulmod(s, rinv,n);//sr^-1\\n\\n        uint256 Qx;\\n        uint256 Qy;\\n        (Qx,Qy)=ecZZ_mulmuladd(r,y, u1, u2);\\n\\n        return address(uint160(uint256(keccak256(abi.encodePacked(Qx, Qy)))));\\n    }\\n\\n    //ecdsa signature for test purpose only (who would like to have a private key onchain anyway ?)\\n    //K is nonce, kpriv is private key\\n    function ecdsa_sign(bytes32 message, uint256 k , uint256 kpriv) public view returns(uint256 r, uint256 s)\\n    {\\n        r=ecZZ_mulmuladd_S_asm(0,0, k, 0) ;//Calculate the curve point k.G (abuse ecmulmul add with v=0)\\n        r=addmod(0,r, n); \\n        s=mulmod(FCL_nModInv(k), addmod(uint256(message), mulmod(r, kpriv, n),n),n);//s=k^-1.(h+r.kpriv)\\n\\n        \\n        if(r==0||s==0){\\n            revert();\\n        }\\n\\n\\n    }\\n\\n} //EOF\\n\",\"keccak256\":\"0xd6c3e555eae02916f6b9d65db6509d7ddf0fd76d5399e29dbc1502e0b7d992a6\",\"license\":\"MIT\"},\"FreshCryptoLib/utils/Base64Url.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Encode (without '=' padding) \\n * @author evmbrahmin, adapted from hiromin's Base64URL libraries\\n */\\nlibrary Base64Url {\\n    /**\\n     * @dev Base64Url Encoding Table\\n     */\\n    string internal constant ENCODING_TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Load the table into memory\\n        string memory table = ENCODING_TABLE;\\n\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        // @solidity memory-safe-assembly\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                mstore8(\\n                    resultPtr,\\n                    mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n\\n                mstore8(\\n                    resultPtr,\\n                    mload(add(tablePtr, and(shr(12, input), 0x3F)))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n\\n                mstore8(\\n                    resultPtr,\\n                    mload(add(tablePtr, and(shr(6, input), 0x3F)))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // Remove the padding adjustment logic\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                // Adjust for the last byte of data\\n                resultPtr := sub(resultPtr, 2)\\n            }\\n            case 2 {\\n                // Adjust for the last two bytes of data\\n                resultPtr := sub(resultPtr, 1)\\n            }\\n            \\n            // Set the correct length of the result string\\n            mstore(result, sub(resultPtr, add(result, 32)))\\n        }\\n\\n        return result;  \\n    }\\n}\\n\",\"keccak256\":\"0xc9d5fbb0ef9ff0756eb5aabe7a32b2bf0f8f3c533d4451dd5778fe77aee7f0c1\",\"license\":\"Apache-2.0\"},\"contracts/FCL/WrapperFCLWebAuthn.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport {FCL_WebAuthn} from \\\"FreshCryptoLib/FCL_Webauthn.sol\\\";\\n\\n/// @title WrapperFCLWebAuthn\\n/// @notice A library used to verify ECDSA signatures over secp256r1 through\\n///         EIP-1271 of Webauthn payloads.\\n/// @dev This lib is only a wrapper around the FCL_WebAuthn library.\\n///      It is meant to be used with 1271 signatures.\\n///      The wrapping is necessary because the FCL_WebAuthn has only internal\\n///      functions and use calldata. This makes it impossible to use it with\\n///      isValidSignature that use memory.\\nlibrary WrapperFCLWebAuthn {\\n    function checkSignature(\\n        bytes calldata authenticatorData,\\n        bytes1 authenticatorDataFlagMask,\\n        bytes calldata clientData,\\n        bytes32 clientChallenge,\\n        uint256 clientChallengeDataOffset,\\n        uint256[2] calldata rs,\\n        uint256[2] calldata Q\\n    ) external view returns (bool) {\\n        return FCL_WebAuthn.checkSignature(\\n            authenticatorData,\\n            authenticatorDataFlagMask,\\n            clientData,\\n            clientChallenge,\\n            clientChallengeDataOffset,\\n            rs,\\n            Q\\n        );\\n    }\\n}\",\"keccak256\":\"0x21b11feafba10e0db2399a46a1d5d30a93c39d0f1c384f43ac43f4988b5d0586\"},\"contracts/P256Signer.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport {WrapperFCLWebAuthn} from \\\"./FCL/WrapperFCLWebAuthn.sol\\\";\\n\\n/// @title P256Signer\\n/// @notice A contract used to verify ECDSA signatures over secp256r1 through\\n///         EIP-1271 of Webauthn payloads.\\n/// @dev This contract is the implementation. It is meant to be used through\\n///      proxy clone.\\ncontract P256Signer {\\n    /// @notice The EIP-1271 magic value\\n    bytes4 internal constant EIP1271_MAGICVALUE = 0x1626ba7e;\\n\\n    /// @notice The old EIP-1271 magic value\\n    bytes4 internal constant OLD_EIP1271_MAGICVALUE = 0x20c13b0b;\\n\\n    /// @notice Whether the contract has been initialized\\n    bool public initialized;\\n\\n    /// @notice The x coordinate of the secp256r1 public key\\n    uint256 public x;\\n\\n    /// @notice The y coordinate of the secp256r1 public key\\n    uint256 public y;\\n\\n    /// @notice Error message when the signature is invalid\\n    error InvalidSignature();\\n\\n    /// @notice Error message when the hash is invalid\\n    error InvalidHash();\\n\\n    /// @notice Error message when the contract is already initialized\\n    error AlreadyInitialized();\\n\\n    constructor() {\\n        initialized = true;\\n    }\\n\\n    /// @notice Verifies that the signer is the owner of the secp256r1 public key.\\n    /// @param _hash The hash of the data signed\\n    /// @param _signature The signature\\n    /// @return The EIP-1271 magic value\\n    function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4) {\\n        _validate(abi.encode(_hash), _signature);\\n        return EIP1271_MAGICVALUE;\\n    }\\n\\n    /// @notice Verifies that the signer is the owner of the secp256r1 public key.\\n    /// @dev This is the old version of the function of EIP-1271 using bytes\\n    ///      memory instead of bytes32\\n    /// @param _hash The hash of the data signed\\n    /// @param _signature The signature\\n    /// @return The EIP-1271 magic value\\n    function isValidSignature(bytes memory _hash, bytes memory _signature) public view returns (bytes4) {\\n        _validate(_hash, _signature);\\n        return OLD_EIP1271_MAGICVALUE;\\n    }\\n\\n    /// @notice Validates the signature\\n    /// @param data The data signed\\n    /// @param _signature The signature\\n    function _validate(bytes memory data, bytes memory _signature) private view {\\n        bytes32 _hash = keccak256(data);\\n        (bytes memory authenticatorData, bytes memory clientData, uint256 challengeOffset, uint256[2] memory rs) =\\n            abi.decode(_signature, (bytes, bytes, uint256, uint256[2]));\\n\\n        bool valid = WrapperFCLWebAuthn.checkSignature(authenticatorData, 0x01, clientData, _hash, challengeOffset, rs, [x, y]);\\n\\n        if (!valid) revert InvalidSignature();\\n    }\\n\\n    /// @dev This function is only callable once and needs to be called immediately\\n    ///      after deployment by the factory in the same transaction.\\n    /// @param x_ The x coordinate of the public key\\n    /// @param y_ The y coordinate of the public key\\n    function initialize(uint256 x_, uint256 y_) external {\\n        if (initialized) revert AlreadyInitialized();\\n        initialized = true;\\n        x = x_;\\n        y = y_;\\n    }\\n}\\n\",\"keccak256\":\"0x1c4a4a8793dd4753832bd31e0a048b87ca2ef9f35b16ee4ee960eca473a4920a\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506000805460ff191660011790556107c18061002d6000396000f3fe608060405234801561001057600080fd5b50600436106100725760003560e01c806320c13b0b1161005057806320c13b0b146100f4578063a56dfe4a14610107578063e4a301161461011057600080fd5b80630c55699c14610077578063158ef93e146100935780631626ba7e146100b0575b600080fd5b61008060015481565b6040519081526020015b60405180910390f35b6000546100a09060ff1681565b604051901515815260200161008a565b6100c36100be366004610475565b610125565b6040517fffffffff00000000000000000000000000000000000000000000000000000000909116815260200161008a565b6100c36101023660046104bc565b61017a565b61008060025481565b61012361011e366004610516565b6101ae565b005b60006101528360405160200161013d91815260200190565b60405160208183030381529060405283610222565b507f1626ba7e0000000000000000000000000000000000000000000000000000000092915050565b60006101868383610222565b507f20c13b0b0000000000000000000000000000000000000000000000000000000092915050565b60005460ff16156101eb576040517f0dc149f000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600190811790915591909155600255565b6000828051906020012090506000806000808580602001905181019061024891906105a9565b935093509350935060007321D84679F9dd3f0e4914a806113CF329368d5253630d5efec9866001878a8888604051806040016040528060015481526020016002548152506040518863ffffffff1660e01b81526004016102ae97969594939291906106da565b602060405180830381865af41580156102cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ef9190610762565b905080610328576040517f8baa579f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561038457610384610332565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156103d1576103d1610332565b604052919050565b600067ffffffffffffffff8211156103f3576103f3610332565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f83011261043057600080fd5b813561044361043e826103d9565b61038a565b81815284602083860101111561045857600080fd5b816020850160208301376000918101602001919091529392505050565b6000806040838503121561048857600080fd5b82359150602083013567ffffffffffffffff8111156104a657600080fd5b6104b28582860161041f565b9150509250929050565b600080604083850312156104cf57600080fd5b823567ffffffffffffffff808211156104e757600080fd5b6104f38683870161041f565b9350602085013591508082111561050957600080fd5b506104b28582860161041f565b6000806040838503121561052957600080fd5b50508035926020909101359150565b60005b8381101561055357818101518382015260200161053b565b50506000910152565b600082601f83011261056d57600080fd5b815161057b61043e826103d9565b81815284602083860101111561059057600080fd5b6105a1826020830160208701610538565b949350505050565b60008060008060a085870312156105bf57600080fd5b845167ffffffffffffffff808211156105d757600080fd5b6105e38883890161055c565b95506020915081870151818111156105fa57600080fd5b61060689828a0161055c565b955050506040860151925086607f87011261062057600080fd5b610628610361565b8060a088018981111561063a57600080fd5b606089015b81811015610656578051845292840192840161063f565b505080935050505092959194509250565b6000815180845261067f816020860160208601610538565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b8060005b60028110156106d45781518452602093840193909101906001016106b5565b50505050565b60006101208083526106ee8184018b610667565b90507fff000000000000000000000000000000000000000000000000000000000000008960f81b166020840152828103604084015261072d8189610667565b91505085606083015284608083015261074960a08301856106b1565b61075660e08301846106b1565b98975050505050505050565b60006020828403121561077457600080fd5b8151801515811461078457600080fd5b939250505056fea26469706673582212207cd1278d2c8b4857225fb653cc9b5ae2215dc6321928bc580a16e6fac9c293ec64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100725760003560e01c806320c13b0b1161005057806320c13b0b146100f4578063a56dfe4a14610107578063e4a301161461011057600080fd5b80630c55699c14610077578063158ef93e146100935780631626ba7e146100b0575b600080fd5b61008060015481565b6040519081526020015b60405180910390f35b6000546100a09060ff1681565b604051901515815260200161008a565b6100c36100be366004610475565b610125565b6040517fffffffff00000000000000000000000000000000000000000000000000000000909116815260200161008a565b6100c36101023660046104bc565b61017a565b61008060025481565b61012361011e366004610516565b6101ae565b005b60006101528360405160200161013d91815260200190565b60405160208183030381529060405283610222565b507f1626ba7e0000000000000000000000000000000000000000000000000000000092915050565b60006101868383610222565b507f20c13b0b0000000000000000000000000000000000000000000000000000000092915050565b60005460ff16156101eb576040517f0dc149f000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016600190811790915591909155600255565b6000828051906020012090506000806000808580602001905181019061024891906105a9565b9350935093509350600073__$d89787f8caa2dcaf364e9349db6aeaba37$__630d5efec9866001878a8888604051806040016040528060015481526020016002548152506040518863ffffffff1660e01b81526004016102ae97969594939291906106da565b602060405180830381865af41580156102cb573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ef9190610762565b905080610328576040517f8baa579f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040805190810167ffffffffffffffff8111828210171561038457610384610332565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff811182821017156103d1576103d1610332565b604052919050565b600067ffffffffffffffff8211156103f3576103f3610332565b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b600082601f83011261043057600080fd5b813561044361043e826103d9565b61038a565b81815284602083860101111561045857600080fd5b816020850160208301376000918101602001919091529392505050565b6000806040838503121561048857600080fd5b82359150602083013567ffffffffffffffff8111156104a657600080fd5b6104b28582860161041f565b9150509250929050565b600080604083850312156104cf57600080fd5b823567ffffffffffffffff808211156104e757600080fd5b6104f38683870161041f565b9350602085013591508082111561050957600080fd5b506104b28582860161041f565b6000806040838503121561052957600080fd5b50508035926020909101359150565b60005b8381101561055357818101518382015260200161053b565b50506000910152565b600082601f83011261056d57600080fd5b815161057b61043e826103d9565b81815284602083860101111561059057600080fd5b6105a1826020830160208701610538565b949350505050565b60008060008060a085870312156105bf57600080fd5b845167ffffffffffffffff808211156105d757600080fd5b6105e38883890161055c565b95506020915081870151818111156105fa57600080fd5b61060689828a0161055c565b955050506040860151925086607f87011261062057600080fd5b610628610361565b8060a088018981111561063a57600080fd5b606089015b81811015610656578051845292840192840161063f565b505080935050505092959194509250565b6000815180845261067f816020860160208601610538565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b8060005b60028110156106d45781518452602093840193909101906001016106b5565b50505050565b60006101208083526106ee8184018b610667565b90507fff000000000000000000000000000000000000000000000000000000000000008960f81b166020840152828103604084015261072d8189610667565b91505085606083015284608083015261074960a08301856106b1565b61075660e08301846106b1565b98975050505050505050565b60006020828403121561077457600080fd5b8151801515811461078457600080fd5b939250505056fea26469706673582212207cd1278d2c8b4857225fb653cc9b5ae2215dc6321928bc580a16e6fac9c293ec64736f6c63430008140033",
  "libraries": {
    "WrapperFCLWebAuthn": "0x21D84679F9dd3f0e4914a806113CF329368d5253"
  },
  "devdoc": {
    "details": "This contract is the implementation. It is meant to be used through      proxy clone.",
    "kind": "dev",
    "methods": {
      "initialize(uint256,uint256)": {
        "details": "This function is only callable once and needs to be called immediately      after deployment by the factory in the same transaction.",
        "params": {
          "x_": "The x coordinate of the public key",
          "y_": "The y coordinate of the public key"
        }
      },
      "isValidSignature(bytes,bytes)": {
        "details": "This is the old version of the function of EIP-1271 using bytes      memory instead of bytes32",
        "params": {
          "_hash": "The hash of the data signed",
          "_signature": "The signature"
        },
        "returns": {
          "_0": "The EIP-1271 magic value"
        }
      },
      "isValidSignature(bytes32,bytes)": {
        "params": {
          "_hash": "The hash of the data signed",
          "_signature": "The signature"
        },
        "returns": {
          "_0": "The EIP-1271 magic value"
        }
      }
    },
    "title": "P256Signer",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "AlreadyInitialized()": [
        {
          "notice": "Error message when the contract is already initialized"
        }
      ],
      "InvalidHash()": [
        {
          "notice": "Error message when the hash is invalid"
        }
      ],
      "InvalidSignature()": [
        {
          "notice": "Error message when the signature is invalid"
        }
      ]
    },
    "kind": "user",
    "methods": {
      "initialized()": {
        "notice": "Whether the contract has been initialized"
      },
      "isValidSignature(bytes,bytes)": {
        "notice": "Verifies that the signer is the owner of the secp256r1 public key."
      },
      "isValidSignature(bytes32,bytes)": {
        "notice": "Verifies that the signer is the owner of the secp256r1 public key."
      },
      "x()": {
        "notice": "The x coordinate of the secp256r1 public key"
      },
      "y()": {
        "notice": "The y coordinate of the secp256r1 public key"
      }
    },
    "notice": "A contract used to verify ECDSA signatures over secp256r1 through         EIP-1271 of Webauthn payloads.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 1989,
        "contract": "contracts/P256Signer.sol:P256Signer",
        "label": "initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 1992,
        "contract": "contracts/P256Signer.sol:P256Signer",
        "label": "x",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      },
      {
        "astId": 1995,
        "contract": "contracts/P256Signer.sol:P256Signer",
        "label": "y",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}